<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · ChebyshevExpansions.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://fernandopenaranda.github.io/ChebyshevExpansions.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><script src="../copy.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>ChebyshevExpansions.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/fernandopenaranda/ChebyshevExpansions.jl/blob/master/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="ChebyshevExpansions"><a class="docs-heading-anchor" href="#ChebyshevExpansions">ChebyshevExpansions</a><a id="ChebyshevExpansions-1"></a><a class="docs-heading-anchor-permalink" href="#ChebyshevExpansions" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/fernandopenaranda/ChebyshevExpansions.jl">ChebyshevExpansions</a>.</p><ul><li><a href="#ChebyshevExpansions.ChebyshevExpansions"><code>ChebyshevExpansions.ChebyshevExpansions</code></a></li><li><a href="#ChebyshevExpansions.averageKPM-Tuple{Any, Any}"><code>ChebyshevExpansions.averageKPM</code></a></li><li><a href="#ChebyshevExpansions.densityKPM-Tuple{Any, Any}"><code>ChebyshevExpansions.densityKPM</code></a></li><li><a href="#ChebyshevExpansions.dosKPM-Tuple{Any}"><code>ChebyshevExpansions.dosKPM</code></a></li><li><a href="#ChebyshevExpansions.momentaKPM"><code>ChebyshevExpansions.momentaKPM</code></a></li><li><a href="#ChebyshevExpansions.randomkets-Tuple{Any, Any, Any}"><code>ChebyshevExpansions.randomkets</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="ChebyshevExpansions.ChebyshevExpansions" href="#ChebyshevExpansions.ChebyshevExpansions"><code>ChebyshevExpansions.ChebyshevExpansions</code></a> — <span class="docstring-category">Module</span></header><section><div><p><strong>ChebyExpansions.jl</strong></p><p><strong>Introduction</strong></p><p>In this package, we implement the <a href="https://journals.aps.org/rmp/abstract/10.1103/RevModPhys.78.275">Kernel Polynomial Method (KPM)</a> [1] in Julia, an efficient technique to compute spectral and correlation functions using order-N Chebyshev expansions of said quantities. </p><p>Diagonalization in KPM is replaced by matrix multiplications and, thus, the resource consumption for a given precision drops to  &lt;img src=&quot;https://latex.codecogs.com/svg.image?\mathcal{O}(D)&quot; title=&quot;\mathcal{O}(D)&quot; /&gt; for sparse or &lt;img src=&quot;https://latex.codecogs.com/svg.image?\mathcal{O}(D^2)&quot; /&gt; for dense matrices, being &lt;img src=&quot;https://latex.codecogs.com/svg.image?D&quot; /&gt;  the matrix dimension. </p><p>In this regard, this technique is well suited for <strong>large matrix calculations</strong> where exact diagonalization becomes too expensive, e.g. when computing the density of states of a large multiorbital system.</p><p>In addition, KPM offers some advantages in terms of stability and resource consumption with respect to other recursive methods such as Lanczos-based techniques, see [1] for a comprehensive review. </p><p><strong>Practical considerations</strong></p><ol><li>The energy resolution is controlled by the ratio &lt;img src=&quot;https://latex.codecogs.com/svg.image?W/N&quot; /&gt; , where &lt;img src=&quot;https://latex.codecogs.com/svg.image?W&quot; /&gt;  is the bandwidth of &lt;img src=&quot;https://latex.codecogs.com/svg.image?H&quot; /&gt;  and &lt;img src=&quot;https://latex.codecogs.com/svg.image?N&quot; /&gt;  the expansion order. The complexity for sparse matrices goes like &lt;img src=&quot;https://latex.codecogs.com/svg.image?\mathcal{O}(ND)&quot; title=&quot;\mathcal{O}(ND)&quot; /&gt;</li><li>The error in the stochastic trace estimation &lt;img src=&quot;https://latex.codecogs.com/svg.image?&amp;space;\mathcal{O}(1/\sqrt{DR})&quot; title=&quot; \mathcal{O}(1/\sqrt{DR})&quot; /&gt;, being &lt;img src=&quot;https://latex.codecogs.com/svg.image?R&quot; /&gt; the number of random kets considered.</li><li>For sparse matrices (the usual scenario), the preferred type of <code>h</code> and <code>A</code> matrices should be <code>AbstractSparseMatrix</code> (although it is not required).</li></ol><p><strong>Observables</strong></p><p>Currently, given a hamiltonian matrix, &lt;img src=&quot;https://latex.codecogs.com/svg.image?H&quot; /&gt; and a generic operator &lt;img src=&quot;https://latex.codecogs.com/svg.image?A&quot; /&gt; the following methods are implemented:</p><ul><li>Momenta computation corresponding to traces over the product of Chebyshev polynomials of &lt;img src=&quot;https://latex.codecogs.com/svg.image?H &quot; /&gt; and &lt;img src=&quot;https://latex.codecogs.com/svg.image?A &quot; /&gt;: &lt;img src=&quot;https://latex.codecogs.com/svg.image?\mu<em>n&amp;space;=&amp;space;\text{Tr}[A&amp;space;T</em>n(H)]&quot; title=&quot;\mu<em>n = \text{Tr}[A T</em>n(H)]&quot; /&gt;.</li><li>Calculation of spectral densities of an operator &lt;img src=&quot;https://latex.codecogs.com/svg.image?A(E)&amp;space;=&amp;space;\text{Tr}&amp;space;[A&amp;space;\delta(E-H)]&quot; title=&quot;A(E) = \text{Tr} [A \delta(E-H)]&quot; /&gt;.</li><li>Calculation of thermal averages, i.e. &lt;img src=&quot;https://latex.codecogs.com/svg.image?\langle&amp;space;A\rangle&amp;space;<em>{E</em>F}&amp;space;=&amp;space;\text{Tr}&amp;space;[A&amp;space;f(H,E<em>F)]&quot; title=&quot;\langle A\rangle _{E</em>F} = \text{Tr} [A f(H,E_F)]&quot; /&gt;.</li></ul><p>Although, currently not implemented KPM momenta from <code>momentaKPM</code> can be used as the basis for a Chebyshev expansion of many interesting functions and observables such as correlation (Green&#39;s) functions, optical conductivities[1], equilibrium supercurrents[2]... </p><p><strong>Exported functions</strong></p><p><code>randomkets, momentaKPM, densityKPM, dosKPM, averageKPM</code></p><ol><li><code>randomkets</code> generates a collection of random kets for stochastic trace estimation</li><li><code>momentaKPM</code> computes the Kernel Polynomial Method (KPM) momenta corresponding to the spectral densities or thermal average calculations</li><li><code>densityKPM</code> computes the spectral density of some operator <code>A::AbstractMatrix</code> given a hamiltonian matrix <code>h::AbstractMatrix</code> using <code>momentaKPM</code></li><li><code>dosKPM</code> computes the density of states of <code>h::AbstractMatrix</code>. Note that &lt;img src=&quot;https://latex.codecogs.com/svg.image?(A&amp;space;==&amp;space;I)&quot; title=&quot;(A == I)&quot; /&gt;</li><li><code>averageKPM()</code> Thermal average KPM calculation of <code>A</code> given <code>h</code>. Finite temperature <code>kBT != 0</code>is not yet implemented.  </li></ol><p><strong>Gallery</strong></p><p><strong>Density of states of a graphene flake</strong></p><p>System size: D = dim(h) = 1e6 Resource consumption: 28.73 k allocations: 702.757 MiB</p><p><img src="https://i.imgur.com/5SlAYmE.png" alt/></p><p><strong>References</strong></p><p>[1] A. Weiße, G. Wellein, A. Alvermann, and H. Fehske, <em>The kernel polynomial method</em>, <a href="https://journals.aps.org/rmp/abstract/10.1103/RevModPhys.78.275">Reviews of Modern Physics <strong>78</strong>, 275 (2006)</a>.</p><p>[2] M. Irfan, S. R.Kuppuswamy, D. Varjas, P. M. Perez-Piskunow, R. Skolasinski, M. Wimmer, &amp; A. R.  Akhmerov, (2019). <em>Hybrid kernel polynomial method</em>, <a href="https://arxiv.org/abs/1909.09649v2">arXiv: arXiv:1909.09649v2</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fernandopenaranda/ChebyshevExpansions.jl/blob/402a682cc0036dddafcc3f638b9504c252ae51be/src/ChebyshevExpansions.jl#L3-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChebyshevExpansions.averageKPM-Tuple{Any, Any}" href="#ChebyshevExpansions.averageKPM-Tuple{Any, Any}"><code>ChebyshevExpansions.averageKPM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">`averageKPM(h::Hamiltonian, A; kBT = 0, Ef = 0, kw...)`</code></pre><p>Compute, using the Kernel Polynomial Method (KPM), the thermal expectation value <code>⟨A⟩ = Σ_k f(E_k) ⟨k|A|k⟩ = ∫dE f(E) Tr [A δ(E-H)]/N₀ = Tr [A f(H)]/N₀</code> for a given hermitian operator <code>A</code> and a zero-dimensional hamiltonian <code>h</code> with a total of <code>N₀</code> orbitals (see <code>momentaKPM</code> and its options <code>kw</code> for further details). <code>f(E)</code> is the Fermi-Dirac distribution function, <code>|k⟩</code> are <code>h</code> eigenstates with energy <code>E_k</code>, kBT<code>is the temperature in energy units and</code>Ef` the Fermi energy.</p><pre><code class="nohighlight hljs">`averageKPM(μ::MomentaKPM, A; kBT = 0, Ef = 0)``</code></pre><p>Same as above with the KPM momenta as input (see <code>momentaKPM</code>).</p><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`dosKPM`, `momentaKPM`, `averageKPM`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fernandopenaranda/ChebyshevExpansions.jl/blob/402a682cc0036dddafcc3f638b9504c252ae51be/src/KPM.jl#L333-L349">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChebyshevExpansions.densityKPM-Tuple{Any, Any}" href="#ChebyshevExpansions.densityKPM-Tuple{Any, Any}"><code>ChebyshevExpansions.densityKPM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">densityKPM(h::Hamiltonian, A; resolution = 2, kets = randomkets(1), kw...)</code></pre><p>Compute, using the Kernel Polynomial Method (KPM), the local density of states <code>ρₖ(ϵ) = ⟨k|δ(ϵ-h)|k⟩</code> for a single ket <code>|k⟩</code>, a collection of <code>{|k_i⟩}</code>, or a set of randomly- generated kets for a stochastic trace calculation(see <code>momentaKPM</code>).</p><p>The result is a tuple of energy points <code>ϵᵢ::Vector</code> spanning the band  range, and real  <code>ρᴬₖ(ϵᵢ)::Vector</code> values. The number of energy points <code>ϵᵢ</code> is <code>order *resolution</code>,  rounded to the closest integer.</p><p>If <code>kets</code> contains more than a single ket, the sum <code>∑ₖρₖ(ε)</code> over all models will be computed. In the case of the default <code>kets = randomkets(h, I, n)</code>, this results in an estimate of the total density of states per orbital, computed through an stochastic trace,  <code>ρ(ϵ) = ∑ₖ⟨k|δ(ϵ-h)|k⟩/n ≈ Tr[δ(ϵ-h)]/N₀</code>, where <code>N₀</code> is the total number of orbitals in the unit cell.</p><pre><code class="nohighlight hljs">`densityKPM(μ::MomentaKPM; resolution = 2)`</code></pre><p>Same as above with KPM momenta <code>μ</code> as input.</p><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`dosKPM`, `momentaKPM`, `averageKPM`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fernandopenaranda/ChebyshevExpansions.jl/blob/402a682cc0036dddafcc3f638b9504c252ae51be/src/KPM.jl#L294-L317">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChebyshevExpansions.dosKPM-Tuple{Any}" href="#ChebyshevExpansions.dosKPM-Tuple{Any}"><code>ChebyshevExpansions.dosKPM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dosKPM(h::Hamiltonian; resolution = 2, kets = randomkets(1), kw...)</code></pre><p>Compute, using the Kernel Polynomial Method (KPM), the local density of states <code>ρₖ(ϵ) = ⟨k|δ(ϵ-h)|k⟩</code> for a single ket <code>|k⟩</code>, a collection of <code>{|k_i⟩}</code>, or a set of randomly- generated kets for a stochastic trace calculation(see <code>momentaKPM</code>).</p><p>The result is a tuple of energy points <code>ϵᵢ::Vector</code> spanning the band range, and real <code>ρₖ(ϵᵢ)::Vector</code> values (any residual imaginary part in <code>ρₖ</code> is dropped). The number of energy points <code>ϵᵢ</code> is <code>order * resolution</code>, rounded to the closest integer.</p><p>If <code>kets</code> contains more than a single ket, the sum <code>∑ₖρₖ(ε)</code> over all models will be computed. In the case of the default <code>kets = randomkets(h, I, n)</code>, this results in an estimate of the total density of states per orbital, computed through an stochastic trace,  <code>ρ(ϵ) = ∑ₖ⟨k|δ(ϵ-h)|k⟩/n ≈ Tr[δ(ϵ-h)]/N₀</code>, where <code>N₀</code> is the total number of orbitals in the unit cell.</p><p><code>dosKPM</code> is a particular case of <code>densityKPM</code> for an operator <code>A = I</code> and with any residual imaginary parts dropped</p><pre><code class="nohighlight hljs">`dosKPM(μ::MomentaKPM; resolution = 2)`</code></pre><p>Same as above with KPM momenta <code>μ</code> as input.</p><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`momentaKPM`, `densityKPM`, `averageKPM`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fernandopenaranda/ChebyshevExpansions.jl/blob/402a682cc0036dddafcc3f638b9504c252ae51be/src/KPM.jl#L262-L288">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChebyshevExpansions.momentaKPM" href="#ChebyshevExpansions.momentaKPM"><code>ChebyshevExpansions.momentaKPM</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">`momentaKPM(h, A = I; kets = randomkets(h, A, n), order = 10, bandrange = missing)`</code></pre><p>Compute the Kernel Polynomial Method (KPM) momenta <code>μₙ = ⟨k|Tₙ(h) A|k⟩</code>, where <code>|k⟩</code> may  either refer to a single ket (kets::AbstractVector), or a set of <code>kets::AbstractMatrix</code>  stored as columns, or to a collection of <code>n</code> random kets generated by <code>randomkets(h, A, n)</code>. <code>A</code> is an observable (<code>AbstractMatrix</code>) and <code>Tₙ(h)</code> is the order-<code>n</code> Chebyshev polynomial of the Hamiltonian <code>h</code>.</p><p>For the randomkets case, <code>μₙ</code> is summed over all kets, <code>μₙ= ∑_k ⟨k|Tₙ(h) A|k⟩</code>.  If <code>kets</code> are a multi-column ket, a sum over columns will similarly be performed. </p><p><code>kets</code> generated with <code>randomkets()</code> are useful to estimate momenta of normalized traces  using the stochastic trace approach, whereby <code>μ_n = Tr[A T_n(h)]/N₀ ≈ ∑ₖ⟨k|A T_n(h)|k⟩</code>.  Here the <code>|k⟩</code>s are <code>n</code> random kets of norm <code>1/√n</code> and <code>N₀</code> is the total number of orbitals per unit cell of <code>h</code> (see <code>randomkets</code>).</p><p>The order of the Chebyshev expansion is <code>order</code>. The <code>bandbrange = (ϵmin, ϵmax)</code> should completely encompass the full bandwidth of <code>hamiltonian</code>. If <code>missing</code> it is computed automatically using <code>ArnoldiMethod</code> (must be loaded <code>using ArnoldiMethod</code>). </p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; momentaKPM(h, I, kets = randomkets(h, I, 5), order = 20)

julia&gt; momentaKPM(h, bandrange = (-6,6)).mulist |&gt; length
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fernandopenaranda/ChebyshevExpansions.jl/blob/402a682cc0036dddafcc3f638b9504c252ae51be/src/KPM.jl#L66-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChebyshevExpansions.randomkets-Tuple{Any, Any, Any}" href="#ChebyshevExpansions.randomkets-Tuple{Any, Any, Any}"><code>ChebyshevExpansions.randomkets</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">randomkets(h, A, n)</code></pre><p>Creates <code>n</code> random vectors with length <code>D = dim(h)</code> and stacks them into a <code>D×n</code> matrix. The resulting ket amplitudes are normalized by <code>1/√n</code>.</p><p>This type of ket structure is useful e.g. in stochastic trace evaluation of KPM methods, where the amplitude, <code>a = cis(2pi*rand())</code> is chosen as a random function s.t. <code>⟨a⟩ = 0</code>, <code>⟨aa⟩ = 0</code> and <code>⟨a&#39;a⟩ = 1</code>. Then, the normalized trace of an operator <code>A</code> can be estimated with <code>Tr[A]/N₀ ≈ ∑⟨ket|A|ket⟩</code>, where the sum is taken over the <code>n</code> random kets <code>|ket⟩</code> of norm <code>1/√n</code> produced by <code>randomkets</code>, and <code>N₀</code> is the total number of orbitals in the full unit cell.</p><p>By default when applied to a multiorbital system with a maximum of <code>N</code> orbitals per site,  the generated kets have independent, complex, normally-distributed random components </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fernandopenaranda/ChebyshevExpansions.jl/blob/402a682cc0036dddafcc3f638b9504c252ae51be/src/KPM.jl#L4-L20">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.12 on <span class="colophon-date" title="Monday 21 February 2022 19:08">Monday 21 February 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
