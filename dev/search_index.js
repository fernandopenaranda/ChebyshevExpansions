var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = ChebyshevExpansions","category":"page"},{"location":"#ChebyshevExpansions","page":"Home","title":"ChebyshevExpansions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for ChebyshevExpansions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [ChebyshevExpansions]","category":"page"},{"location":"#ChebyshevExpansions.ChebyshevExpansions","page":"Home","title":"ChebyshevExpansions.ChebyshevExpansions","text":"ChebyExpansions.jl\n\nIntroduction\n\nIn this package, we implement the Kernel Polynomial Method (KPM) [1] in Julia, an efficient technique to compute spectral and correlation functions using order-N Chebyshev expansions of said quantities. \n\nDiagonalization in KPM is replaced by matrix multiplications and, thus, the resource consumption for a given precision drops to  <img src=\"https://latex.codecogs.com/svg.image?\\mathcal{O}(D)\" title=\"\\mathcal{O}(D)\" /> for sparse or <img src=\"https://latex.codecogs.com/svg.image?\\mathcal{O}(D^2)\" /> for dense matrices, being <img src=\"https://latex.codecogs.com/svg.image?D\" />  the matrix dimension. \n\nIn this regard, this technique is well suited for large matrix calculations where exact diagonalization becomes too expensive, e.g. when computing the density of states of a large multiorbital system.\n\nIn addition, KPM offers some advantages in terms of stability and resource consumption with respect to other recursive methods such as Lanczos-based techniques, see [1] for a comprehensive review. \n\nPractical considerations\n\nThe energy resolution is controlled by the ratio <img src=\"https://latex.codecogs.com/svg.image?W/N\" /> , where <img src=\"https://latex.codecogs.com/svg.image?W\" />  is the bandwidth of <img src=\"https://latex.codecogs.com/svg.image?H\" />  and <img src=\"https://latex.codecogs.com/svg.image? N\" />  the expansion order. The complexity for sparse matrices goes like <img src=\"https://latex.codecogs.com/svg.image?\\mathcal O(ND)\" /> \nThe error in the stochastic trace estimation <img src=\"https://latex.codecogs.com/svg.image? \\mathcal{O}(1/\\sqrt{DR})\" /> , being <img src=\"https://latex.codecogs.com/svg.image? R\" /> the number of random kets considered.\nFor sparse matrices (the usual scenario) h and A should be AbstractSparseMatrix the preferred type (although it is not required).\n\nObservables\n\nCurrently, given a hamiltonian matrix, <img src=\"https://latex.codecogs.com/svg.image? H\" /> and a generic operator A the following methods are implemented:\n\nMomenta computation corresponding to traces over the product of Chebyshev polynomials of <img src=\"https://latex.codecogs.com/svg.image? H\" /> and <img src=\"https://latex.codecogs.com/svg.image? A\" />: <img src=\"https://latex.codecogs.com/svg.image? \\mun = \\text{Tr}[A Tn(H)]\" />.\nCalculation of spectral densities of an operator <img src=\"https://latex.codecogs.com/svg.image? A(E) = \\text{Tr} [A \\delta(E-H)]\" />.\nCalculation of thermal averages, i.e. <img src=\"https://latex.codecogs.com/svg.image? \\langle A\\rangle {EF} = \\text{Tr} [A f(H,E_F)]\" /> \n\nAlthough, currently not implemented KPM momenta from momentaKPM can be used as the basis for a Chebyshev expansion of many interesting functions and observables such as correlation (Green's) functions, optical conductivities[1], equilibrium supercurrents[2]... \n\nExported functions\n\nrandomkets, momentaKPM, densityKPM, dosKPM, averageKPM\n\nrandomkets generates a collection of random kets for stochastic trace estimation\nmomentaKPM computes the Kernel Polynomial Method (KPM) momenta corresponding to the spectral densities or thermal average calculations\ndensityKPM computes the spectral density of some operator A::AbstractMatrix given a hamiltonian matrix h::AbstractMatrix using momentaKPM\ndosKPM computes the density of states of h::AbstractMatrix. Note that  <img src=\"https://latex.codecogs.com/svg.image? (A == I)\" /> \naverageKPM() Thermal average KPM calculation of A given h. Finite temperature kBT != 0is not yet implemented.  \n\nReferences\n\n[1] A. Weiße, G. Wellein, A. Alvermann, and H. Fehske, The kernel polynomial method, Reviews of Modern Physics 78, 275 (2006).\n\n[2] M. Irfan, S. R.Kuppuswamy, D. Varjas, P. M. Perez-Piskunow, R. Skolasinski, M. Wimmer, & A. R.  Akhmerov, (2019). Hybrid kernel polynomial method, arXiv: arXiv:1909.09649v2.\n\n\n\n\n\n","category":"module"},{"location":"#ChebyshevExpansions.averageKPM-Tuple{Any, Any}","page":"Home","title":"ChebyshevExpansions.averageKPM","text":"`averageKPM(h::Hamiltonian, A; kBT = 0, Ef = 0, kw...)`\n\nCompute, using the Kernel Polynomial Method (KPM), the thermal expectation value ⟨A⟩ = Σ_k f(E_k) ⟨k|A|k⟩ = ∫dE f(E) Tr [A δ(E-H)]/N₀ = Tr [A f(H)]/N₀ for a given hermitian operator A and a zero-dimensional hamiltonian h with a total of N₀ orbitals (see momentaKPM and its options kw for further details). f(E) is the Fermi-Dirac distribution function, |k⟩ are h eigenstates with energy E_k, kBTis the temperature in energy units andEf` the Fermi energy.\n\n`averageKPM(μ::MomentaKPM, A; kBT = 0, Ef = 0)``\n\nSame as above with the KPM momenta as input (see momentaKPM).\n\nSee also\n\n`dosKPM`, `momentaKPM`, `averageKPM`\n\n\n\n\n\n","category":"method"},{"location":"#ChebyshevExpansions.densityKPM-Tuple{Any, Any}","page":"Home","title":"ChebyshevExpansions.densityKPM","text":"densityKPM(h::Hamiltonian, A; resolution = 2, kets = randomkets(1), kw...)\n\nCompute, using the Kernel Polynomial Method (KPM), the local density of states ρₖ(ϵ) = ⟨k|δ(ϵ-h)|k⟩ for a single ket |k⟩, a collection of {|k_i⟩}, or a set of randomly- generated kets for a stochastic trace calculation(see momentaKPM).\n\nThe result is a tuple of energy points ϵᵢ::Vector spanning the band  range, and real  ρᴬₖ(ϵᵢ)::Vector values. The number of energy points ϵᵢ is order *resolution,  rounded to the closest integer.\n\nIf kets contains more than a single ket, the sum ∑ₖρₖ(ε) over all models will be computed. In the case of the default kets = randomkets(h, I, n), this results in an estimate of the total density of states per orbital, computed through an stochastic trace,  ρ(ϵ) = ∑ₖ⟨k|δ(ϵ-h)|k⟩/n ≈ Tr[δ(ϵ-h)]/N₀, where N₀ is the total number of orbitals in the unit cell.\n\n`densityKPM(μ::MomentaKPM; resolution = 2)`\n\nSame as above with KPM momenta μ as input.\n\nSee also\n\n`dosKPM`, `momentaKPM`, `averageKPM`\n\n\n\n\n\n","category":"method"},{"location":"#ChebyshevExpansions.dosKPM-Tuple{Any}","page":"Home","title":"ChebyshevExpansions.dosKPM","text":"dosKPM(h::Hamiltonian; resolution = 2, kets = randomkets(1), kw...)\n\nCompute, using the Kernel Polynomial Method (KPM), the local density of states ρₖ(ϵ) = ⟨k|δ(ϵ-h)|k⟩ for a single ket |k⟩, a collection of {|k_i⟩}, or a set of randomly- generated kets for a stochastic trace calculation(see momentaKPM).\n\nThe result is a tuple of energy points ϵᵢ::Vector spanning the band range, and real ρₖ(ϵᵢ)::Vector values (any residual imaginary part in ρₖ is dropped). The number of energy points ϵᵢ is order * resolution, rounded to the closest integer.\n\nIf kets contains more than a single ket, the sum ∑ₖρₖ(ε) over all models will be computed. In the case of the default kets = randomkets(h, I, n), this results in an estimate of the total density of states per orbital, computed through an stochastic trace,  ρ(ϵ) = ∑ₖ⟨k|δ(ϵ-h)|k⟩/n ≈ Tr[δ(ϵ-h)]/N₀, where N₀ is the total number of orbitals in the unit cell.\n\ndosKPM is a particular case of densityKPM for an operator A = I and with any residual imaginary parts dropped\n\n`dosKPM(μ::MomentaKPM; resolution = 2)`\n\nSame as above with KPM momenta μ as input.\n\nSee also\n\n`momentaKPM`, `densityKPM`, `averageKPM`\n\n\n\n\n\n","category":"method"},{"location":"#ChebyshevExpansions.momentaKPM","page":"Home","title":"ChebyshevExpansions.momentaKPM","text":"`momentaKPM(h, A = I; kets = randomkets(h, A, n), order = 10, bandrange = missing)`\n\nCompute the Kernel Polynomial Method (KPM) momenta μₙ = ⟨k|Tₙ(h) A|k⟩, where |k⟩ may  either refer to a single ket (kets::AbstractVector), or a set of kets::AbstractMatrix  stored as columns, or to a collection of n random kets generated by randomkets(h, A, n). A is an observable (AbstractMatrix) and Tₙ(h) is the order-n Chebyshev polynomial of the Hamiltonian h.\n\nFor the randomkets case, μₙ is summed over all kets, μₙ= ∑_k ⟨k|Tₙ(h) A|k⟩.  If kets are a multi-column ket, a sum over columns will similarly be performed. \n\nkets generated with randomkets() are useful to estimate momenta of normalized traces  using the stochastic trace approach, whereby μ_n = Tr[A T_n(h)]/N₀ ≈ ∑ₖ⟨k|A T_n(h)|k⟩.  Here the |k⟩s are n random kets of norm 1/√n and N₀ is the total number of orbitals per unit cell of h (see randomkets).\n\nThe order of the Chebyshev expansion is order. The bandbrange = (ϵmin, ϵmax) should completely encompass the full bandwidth of hamiltonian. If missing it is computed automatically using ArnoldiMethod (must be loaded using ArnoldiMethod). \n\nExamples\n\njulia> momentaKPM(h, I, kets = randomkets(h, I, 5), order = 20)\n\njulia> momentaKPM(h, bandrange = (-6,6)).mulist |> length\n\n\n\n\n\n\n","category":"function"},{"location":"#ChebyshevExpansions.randomkets-Tuple{Any, Any, Any}","page":"Home","title":"ChebyshevExpansions.randomkets","text":"randomkets(h, A, n)\n\nCreates n random vectors with length D = dim(h) and stacks them into a D×n matrix. The resulting ket amplitudes are normalized by 1/√n.\n\nThis type of ket structure is useful e.g. in stochastic trace evaluation of KPM methods, where the amplitude, a = cis(2pi*rand()) is chosen as a random function s.t. ⟨a⟩ = 0, ⟨aa⟩ = 0 and ⟨a'a⟩ = 1. Then, the normalized trace of an operator A can be estimated with Tr[A]/N₀ ≈ ∑⟨ket|A|ket⟩, where the sum is taken over the n random kets |ket⟩ of norm 1/√n produced by randomkets, and N₀ is the total number of orbitals in the full unit cell.\n\nBy default when applied to a multiorbital system with a maximum of N orbitals per site,  the generated kets have independent, complex, normally-distributed random components \n\n\n\n\n\n","category":"method"}]
}
