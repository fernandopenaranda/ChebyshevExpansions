var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = ChebyshevExpansions","category":"page"},{"location":"#ChebyshevExpansions","page":"Home","title":"ChebyshevExpansions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for ChebyshevExpansions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [ChebyshevExpansions]","category":"page"},{"location":"#ChebyshevExpansions.ChebyshevExpansions","page":"Home","title":"ChebyshevExpansions.ChebyshevExpansions","text":"ChebyshevExpansions\n\n(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage)\n\nChebyExpansions.jl\n\nIntroduction\n\nIn this package, we implement the Kernel Polynomial Method (KPM) in Julia, an efficient technique to compute spectral and correlation functions using order-N Chebyshev expansions of said quantities. \n\nDiagonalization in KPM is replaced by matrix multiplications and, thus, the resource consumption for a given precission drops to mathcalO(D) for sparse or mathcalO(D^2) for dense matrices, being D the matrix dimension. \n\nIn this regard, this technique is well suited for large matrix calculations where exact diagonalization becomes too expensive. In addition, KPM offers some advantages in terms of stability and resource consumption with respect to other recursive methods such as Lanczos-based techniques, see [1] for a comprehensive review. \n\nPractical considerations\n\nThe energy resolution is controlled by the ratio WN, where W is the bandwidth of H and N the expansion order. The complexity for sparse matrices goes like mathcal O(ND)\nThe error in the stochastic trace estimation mathcalO(1sqrtDR), being R the number of random kets considered.\n\nObservables\n\nCurrently, given a hamiltonian matrix, H and a generic operator A the following methods are implemented:\n\nMomenta computation corresponding to traces over the product of Chebyshev polynomials of H and A: mu_n = textTrA T_n(H).\nCalculation of spectral densities of an operator A(E) = textTr A 𝛿(E-H).\nCalculation of thermal averages, i.e. langle Arangle _E_F = textTr A f(HE_F)\n\nExported functions\n\nmomentaKPM dosKPM computes the density of states (A == I) densityKPM  averageKPM \n\nReferences\n\n[1] A. Weiße, G. Wellein, A. Alvermann, and H. Fehske, The kernel polynomial method, Reviews of Modern Physics 78, 275 (2006).\n\n\n\n\n\n","category":"module"},{"location":"#ChebyshevExpansions.basiskets","page":"Home","title":"ChebyshevExpansions.basiskets","text":"basiskets(a = I; kw...)\n\nCreate a multicolumn ket model that represents a basis for sites selected by siteselctor(kw...), with amplitude a on each site. For hamiltonians with N orbitals per site, a will need to be either I or a matrix with N columns. \n\nbasiskets(a; kw...) is equivalent to ketmodel(a; singlesitekets = true, kw...).\n\nSee also\n\n`ket`\n\n\n\n\n\n","category":"function"},{"location":"#ChebyshevExpansions.momentaKPM","page":"Home","title":"ChebyshevExpansions.momentaKPM","text":"randomkets = 1:Int single vector::AbstractVector, or bunch of vectors::AbstractMatrix sorted by columns. Ojo a la normalizaci'on en sistemasmultiorbitales\n\nmomentaKPM(h::Hamiltonian, A = I; ket = randomkets(1), order = 10, bandrange = missing, flat = Val(true))\n\nCompute the Kernel Polynomial Method (KPM) momenta μₙ = ⟨k|Tₙ(h) A|k⟩, where |k⟩ = ket(ket::KetModel, h) or |k⟩ = ket::Ket (depending on the type of ket), A is an observable (Hamiltonian or AbstractMatrix) and Tₙ(h) is the order-n Chebyshev polynomial of the Hamiltonian h.\n\nket can be a single KetModel or Ket, as above, or a collection of them, as in the default ket = randomkets(n). In the latter case, μₙ is summed over all models/kets, μₙ = ∑_k ⟨k|Tₙ(h) A|k⟩. If ket::Ket is a multi-column ket, a sum over columns will similarly be performed. A ket = randomkets(n) produces a lazy collection of n random KetModels that is useful to estimate momenta of normalized traces using the stochastic trace approach, whereby μ_n = Tr[A T_n(h)]/N₀ ≈ ∑ₖ⟨k|A T_n(h)|k⟩. Here the |k⟩s are n random kets of norm 1/√n and N₀ is the total number of orbitals per unit cell of h (see randomkets).\n\nThe order of the Chebyshev expansion is order. The bandbrange = (ϵmin, ϵmax) should completely encompass the full bandwidth of hamiltonian. If missing it is computed automatically using ArnoldiMethod (must be loaded using ArnoldiMethod). flat indicates whether, in the case of multiorbital systems, the internal computations are to be performed using flattened arrays, typically increasing performace by making use of external linear algebra libraries (e.g. MKL or OpenBLAS).\n\nExamples\n\njulia> h = LatticePresets.cubic() |> hamiltonian(hopping(1)) |> unitcell(region = RegionPresets.sphere(10));\n\njulia> momentaKPM(h, bandrange = (-6,6)).mulist |> length\n11\n\n\n\n\n\n","category":"function"},{"location":"#ChebyshevExpansions.randomkets-NTuple{4, Any}","page":"Home","title":"ChebyshevExpansions.randomkets","text":"randomkets(n, a = r -> cis(2pi*rand()); kw...)\n\nCreate a lazy collection of n KetModels of amplitude a, and normalization = 1/√n. Other keyword arguments are forwarded to ketmodel.\n\nThis type of ket model is useful e.g. in stochastic trace evaluation of KPM methods, where the amplitude is chosen as a random function with ⟨a⟩ = 0, ⟨aa⟩ = 0 and ⟨a'a⟩ = 1. The default a is a uniform random phase on each site, which satisties these conditions. Then, the normalized trace of an operator A can be estimated with Tr[A]/N₀ ≈ ∑⟨ket|A|ket⟩, where the sum is taken over the n random kets |ket⟩ of norm 1/√n produced by randomkets, and N₀ is the total number of orbitals in the full unit cell.\n\nTo apply it to a multiorbital system with a maximum of N orbitals per site, a must in general be adapted to produce the desired random SVector{N} (unless maporbitals = true), with the above statistical properties for each orbital. Example: to have independent, complex, normally-distributed random components of two orbitals use randomkets(n, r -> randn(SVector{2,ComplexF64})), or alternatively randomkets(n, r -> randn(ComplexF64), maporbitals = true).\n\nSee also\n\n`ket`\n\n\n\n\n\n","category":"method"}]
}
