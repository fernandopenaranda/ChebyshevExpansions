var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = ChebyshevExpansions","category":"page"},{"location":"#ChebyshevExpansions","page":"Home","title":"ChebyshevExpansions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for ChebyshevExpansions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [ChebyshevExpansions]","category":"page"},{"location":"#ChebyshevExpansions.ChebyshevExpansions","page":"Home","title":"ChebyshevExpansions.ChebyshevExpansions","text":"ChebyshevExpansions\n\n(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage)\n\nChebyExpansions.jl\n\nIntroduction\n\nIn this package, we implement the Kernel Polynomial Method (KPM) in Julia, an efficient technique to compute spectral and correlation functions using order-N Chebyshev expansions of said quantities. \n\nDiagonalization in KPM is replaced by matrix multiplications and, thus, the resource consumption for a given precission drops to mathcalO(D) for sparse or mathcalO(D^2) for dense matrices, being D the matrix dimension. \n\nIn this regard, this technique is well suited for large matrix calculations where exact diagonalization becomes too expensive. In addition, KPM offers some advantages in terms of stability and resource consumption with respect to other recursive methods such as Lanczos-based techniques, see [1] for a comprehensive review. \n\nPractical considerations\n\nThe energy resolution is controlled by the ratio WN, where W is the bandwidth of H and N the expansion order. The complexity for sparse matrices goes like mathcal O(ND)\nThe error in the stochastic trace estimation mathcalO(1sqrtDR), being R the number of random kets considered.\n\nObservables\n\nCurrently, given a hamiltonian matrix, H and a generic operator A the following methods are implemented:\n\nMomenta computation corresponding to traces over the product of Chebyshev polynomials of H and A: mu_n = textTrA T_n(H).\nCalculation of spectral densities of an operator A(E) = textTr A ùõø(E-H).\nCalculation of thermal averages, i.e. langle Arangle _E_F = textTr A f(HE_F)\n\nExported functions\n\nmomentaKPM dosKPM computes the density of states (A == I) densityKPM  averageKPM \n\nReferences\n\n[1] A. Wei√üe, G. Wellein, A. Alvermann, and H. Fehske, The kernel polynomial method, Reviews of Modern Physics 78, 275 (2006).\n\n\n\n\n\n","category":"module"},{"location":"#ChebyshevExpansions.averageKPM-Tuple{Any, Any}","page":"Home","title":"ChebyshevExpansions.averageKPM","text":"`averageKPM(h::Hamiltonian, A; kBT = 0, Ef = 0, kw...)`\n\nCompute, using the Kernel Polynomial Method (KPM), the thermal expectation value ‚ü®A‚ü© = Œ£_k f(E_k) ‚ü®k|A|k‚ü© = ‚à´dE f(E) Tr [A Œ¥(E-H)]/N‚ÇÄ = Tr [A f(H)]/N‚ÇÄ for a given hermitian operator A and a zero-dimensional hamiltonian h with a total of N‚ÇÄ orbitals (see momentaKPM and its options kw for further details). f(E) is the Fermi-Dirac distribution function, |k‚ü© are h eigenstates with energy E_k, kBTis the temperature in energy units andEf` the Fermi energy.\n\n`averageKPM(Œº::MomentaKPM, A; kBT = 0, Ef = 0)``\n\nSame as above with the KPM momenta as input (see momentaKPM).\n\nSee also\n\n`dosKPM`, `momentaKPM`, `averageKPM`\n\n\n\n\n\n","category":"method"},{"location":"#ChebyshevExpansions.densityKPM-Tuple{Any, Any}","page":"Home","title":"ChebyshevExpansions.densityKPM","text":"densityKPM(h::Hamiltonian, A; resolution = 2, kets = randomkets(1), kw...)\n\nCompute, using the Kernel Polynomial Method (KPM), the local density of states œÅ‚Çñ(œµ) = ‚ü®k|Œ¥(œµ-h)|k‚ü© for a single ket |k‚ü©, a collection of {|k_i‚ü©}, or a set of randomly- generated kets for a stochastic trace calculation(see momentaKPM).\n\nThe result is a tuple of energy points œµ·µ¢::Vector spanning the band  range, and real  œÅ·¥¨‚Çñ(œµ·µ¢)::Vector values. The number of energy points œµ·µ¢ is order *resolution,  rounded to the closest integer.\n\nIf kets contains more than a single ket, the sum ‚àë‚ÇñœÅ‚Çñ(Œµ) over all models will be computed. In the case of the default kets = randomkets(h, I, n), this results in an estimate of the total density of states per orbital, computed through an stochastic trace,  œÅ(œµ) = ‚àë‚Çñ‚ü®k|Œ¥(œµ-h)|k‚ü©/n ‚âà Tr[Œ¥(œµ-h)]/N‚ÇÄ, where N‚ÇÄ is the total number of orbitals in the unit cell.\n\n`densityKPM(Œº::MomentaKPM; resolution = 2)`\n\nSame as above with KPM momenta Œº as input.\n\nSee also\n\n`dosKPM`, `momentaKPM`, `averageKPM`\n\n\n\n\n\n","category":"method"},{"location":"#ChebyshevExpansions.dosKPM-Tuple{Any}","page":"Home","title":"ChebyshevExpansions.dosKPM","text":"dosKPM(h::Hamiltonian; resolution = 2, kets = randomkets(1), kw...)\n\nCompute, using the Kernel Polynomial Method (KPM), the local density of states œÅ‚Çñ(œµ) = ‚ü®k|Œ¥(œµ-h)|k‚ü© for a single ket |k‚ü©, a collection of {|k_i‚ü©}, or a set of randomly- generated kets for a stochastic trace calculation(see momentaKPM).\n\nThe result is a tuple of energy points œµ·µ¢::Vector spanning the band range, and real œÅ‚Çñ(œµ·µ¢)::Vector values (any residual imaginary part in œÅ‚Çñ is dropped). The number of energy points œµ·µ¢ is order * resolution, rounded to the closest integer.\n\nIf kets contains more than a single ket, the sum ‚àë‚ÇñœÅ‚Çñ(Œµ) over all models will be computed. In the case of the default kets = randomkets(h, I, n), this results in an estimate of the total density of states per orbital, computed through an stochastic trace,  œÅ(œµ) = ‚àë‚Çñ‚ü®k|Œ¥(œµ-h)|k‚ü©/n ‚âà Tr[Œ¥(œµ-h)]/N‚ÇÄ, where N‚ÇÄ is the total number of orbitals in the unit cell.\n\ndosKPM is a particular case of densityKPM for an operator A = I and with any residual imaginary parts dropped\n\n`dosKPM(Œº::MomentaKPM; resolution = 2)`\n\nSame as above with KPM momenta Œº as input.\n\nSee also\n\n`momentaKPM`, `densityKPM`, `averageKPM`\n\n\n\n\n\n","category":"method"},{"location":"#ChebyshevExpansions.momentaKPM","page":"Home","title":"ChebyshevExpansions.momentaKPM","text":"`momentaKPM(h, A = I; kets = randomkets(h, A, n), order = 10, bandrange = missing)`\n\nCompute the Kernel Polynomial Method (KPM) momenta Œº‚Çô = ‚ü®k|T‚Çô(h) A|k‚ü©, where |k‚ü© may  either refer to a single ket (kets::AbstractVector), or a set of kets::AbstractMatrix  stored as columns, or to a collection of n random kets generated by randomkets(h, A, n). A is an observable (AbstractMatrix) and T‚Çô(h) is the order-n Chebyshev polynomial of the Hamiltonian h.\n\nFor the randomkets case, Œº‚Çô is summed over all kets, Œº‚Çô= ‚àë_k ‚ü®k|T‚Çô(h) A|k‚ü©.  If kets are a multi-column ket, a sum over columns will similarly be performed. \n\nkets generated with randomkets() are useful to estimate momenta of normalized traces  using the stochastic trace approach, whereby Œº_n = Tr[A T_n(h)]/N‚ÇÄ ‚âà ‚àë‚Çñ‚ü®k|A T_n(h)|k‚ü©.  Here the |k‚ü©s are n random kets of norm 1/‚àön and N‚ÇÄ is the total number of orbitals per unit cell of h (see randomkets).\n\nThe order of the Chebyshev expansion is order. The bandbrange = (œµmin, œµmax) should completely encompass the full bandwidth of hamiltonian. If missing it is computed automatically using ArnoldiMethod (must be loaded using ArnoldiMethod). \n\nExamples\n\njulia> momentaKPM(h, I, kets = randomkets(h, I, 5), order = 20)\n\njulia> momentaKPM(h, bandrange = (-6,6)).mulist |> length\n\n\n\n\n\n\n","category":"function"},{"location":"#ChebyshevExpansions.randomkets-Tuple{Any, Any, Any}","page":"Home","title":"ChebyshevExpansions.randomkets","text":"randomkets(h, A, n)\n\nCreates n random vectors with length D = dim(h) and stacks them into a D√ón matrix. The resulting ket amplitudes are normalized by 1/‚àön.\n\nThis type of ket structure is useful e.g. in stochastic trace evaluation of KPM methods, where the amplitude, a = cis(2pi*rand()) is chosen as a random function s.t. ‚ü®a‚ü© = 0, ‚ü®aa‚ü© = 0 and ‚ü®a'a‚ü© = 1. Then, the normalized trace of an operator A can be estimated with Tr[A]/N‚ÇÄ ‚âà ‚àë‚ü®ket|A|ket‚ü©, where the sum is taken over the n random kets |ket‚ü© of norm 1/‚àön produced by randomkets, and N‚ÇÄ is the total number of orbitals in the full unit cell.\n\nBy default when applied to a multiorbital system with a maximum of N orbitals per site,  the generated kets have independent, complex, normally-distributed random components \n\n\n\n\n\n","category":"method"}]
}
